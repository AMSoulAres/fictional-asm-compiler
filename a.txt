#include "Preprocessor.hpp"
#include "Assembler.hpp"
#include <iostream>
#include <string>

// Função auxiliar para trocar a extensão de um nome de arquivo.
std::string change_extension(const std::string& filename, const std::string& new_ext) {
    size_t last_dot = filename.find_last_of(".");
    if (last_dot == std::string::npos) {
        return filename + new_ext;
    }
    return filename.substr(0, last_dot) + new_ext;
}

int main(int argc, char* argv) {
    // Valida os argumentos da linha de comando.
    if (argc!= 2) {
        std::cerr << "Uso:./compilador arquivo.asm" << std::endl;
        return 1;
    }

    // Define os nomes dos arquivos de entrada e saída.
    std::string input_filename = argv[2];
    std::string pre_filename = change_extension(input_filename, ".pre");
    std::string o1_filename = change_extension(input_filename, ".o1");
    std::string o2_filename = change_extension(input_filename, ".o2");

    try {
        // Executa a Passagem 0: Pré-processamento.
        std::cout << "Iniciando Passagem 0: Pre-processamento..." << std::endl;
        Preprocessor preprocessor;
        preprocessor.process(input_filename, pre_filename);
        std::cout << "Pre-processamento concluido. Saida em: " << pre_filename << std::endl;

        // Executa a Passagem 1: Montagem.
        std::cout << "Iniciando Passagem 1: Montagem..." << std::endl;
        Assembler assembler;
        assembler.assemble(pre_filename, o1_filename, o2_filename);
        std::cout << "Montagem concluida. Saidas em: " << o1_filename << " e " << o2_filename << std::endl;

    } catch (const std::exception& e) {
        std::cerr << "Erro fatal durante a compilacao: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}


-------


#include "Assembler.hpp"
#include <fstream>
#include <iostream>
#include <iomanip>

// Inicializa a Tabela de Operações (OPTAB) com todas as instruções da linguagem.
// Estes dados vêm do arquivo Linguagem.txt. [2]
void Assembler::initialize_optab() {
    optab    = {1, 2, 1};
    optab    = {2, 2, 1};
    optab   = {3, 2, 1};
    optab    = {4, 2, 1};
    optab["JMP"]    = {5, 2, 1};
    optab["JMPN"]   = {6, 2, 1};
    optab["JMPP"]   = {7, 2, 1};
    optab["JMPZ"]   = {8, 2, 1};
    optab   = {9, 3, 2};
    optab   = {10, 2, 1};
    optab  = {11, 2, 1};
    optab  = {12, 2, 1};
    optab = {13, 2, 1};
    optab   = {14, 1, 0};
}

// O algoritmo de passagem única, que é o núcleo do montador.
void Assembler::first_pass(const std::string& input_filename) {
    std::ifstream input_file(input_filename);
    if (!input_file.is_open()) {
        throw std::runtime_error("Nao foi possivel abrir o arquivo.pre para montagem.");
    }

    std::string line;
    int line_number = 0;
    int location_counter = 0; // Contador de localização (LC), rastreia o endereço de memória atual.
    std::string pending_label = ""; // Armazena um rótulo que aparece em uma linha sozinho.

    // Lê o arquivo.pre linha por linha.
    while (std::getline(input_file, line)) {
        line_number++;
        try {
            auto tokens = lexer.tokenize(line, line_number);
            if (tokens.empty()) continue;

            size_t token_idx = 0;
            std::string current_label = pending_label;
            pending_label = "";

            // Passo 1: Processar o rótulo, se houver.
            if (tokens.type == TokenType::LABEL) {
                if (!current_label.empty()) {
                    throw std::runtime_error("Dois rotulos na mesma linha.");
                }
                current_label = tokens.value;
                token_idx++;
            }

            if (!current_label.empty()) {
                if (symtab.count(current_label) && symtab[current_label].is_defined) {
                    throw std::runtime_error("Rotulo '" + current_label + "' declarado duas vezes.");
                }
                // Adiciona ou atualiza o rótulo na Tabela de Símbolos (SYMTAB).
                symtab[current_label].address = location_counter;
                symtab[current_label].is_defined = true;
            }
            
            // Se a linha continha apenas um rótulo, armazena-o e passa para a próxima linha.
            if (token_idx >= tokens.size()) { 
                pending_label = current_label;
                continue;
            }

            // Passo 2: Processar o mnemônico e os operandos.
            Token main_token = tokens[token_idx];
            
            if (main_token.type == TokenType::MNEMONIC) {
                const auto& op_info = optab.at(main_token.value);
                if ((tokens.size() - token_idx - 1)!= (size_t)op_info.num_operands) {
                    throw std::runtime_error("Instrucao '" + main_token.value + "' com numero de parametros errado.");
                }
                object_code.push_back(op_info.opcode);

                // Processa cada operando da instrução.
                for (int i = 0; i < op_info.num_operands; ++i) {
                    std::string operand_name = tokens[token_idx + 1 + i].value;
                    
                    // Lógica da referência futura:
                    // Se o símbolo já foi definido, usa seu endereço.
                    if (symtab.count(operand_name) && symtab[operand_name].is_defined) {
                        object_code.push_back(symtab[operand_name].address);
                    } else {
                        // Se não, é uma referência futura. Adiciona um placeholder (0) ao código objeto
                        // e registra a posição atual na lista de pendências do símbolo.
                        object_code.push_back(0); 
                        symtab[operand_name].pending_list.push_back(location_counter + 1 + i);
                    }
                }
                location_counter += op_info.size; // Atualiza o LC.

            } else if (main_token.type == TokenType::DIRECTIVE) {
                if (main_token.value == "SPACE") {
                    int size = 1;
                    if (tokens.size() > token_idx + 1) {
                        size = std::stoi(tokens[token_idx + 1].value);
                    }
                    for (int i = 0; i < size; ++i) object_code.push_back(0);
                    location_counter += size;
                } else if (main_token.value == "CONST") {
                    if (tokens.size() <= token_idx + 1) throw std::runtime_error("Diretiva CONST sem argumento.");
                    object_code.push_back(std::stoi(tokens[token_idx + 1].value));
                    location_counter += 1;
                }
            } else {
                 throw std::runtime_error("Instrucao '" + main_token.value + "' inexistente.");
            }

        } catch (const std::runtime_error& e) {
            errors.push_back({line_number, e.what()});
        } catch (const LexicalError& e) {
            errors.push_back({e.getLine(), e.what()});
        }
    }

    // Passo 3: Verificação final por símbolos não definidos.
    for (const auto& pair : symtab) {
        if (!pair.second.is_defined) {
            errors.push_back({-1, "Erro Semantico: Rotulo '" + pair.first + "' nao declarado."});
        }
    }
}

// Gera o arquivo.o1, que mostra o estado intermediário da compilação.
void Assembler::generate_o1_file(const std::string& filename) {
    std::ofstream file(filename);
    if (!file.is_open()) return;

    file << "--- Codigo Gerado (Antes do Backpatching) ---\n";
    for (size_t i = 0; i < object_code.size(); ++i) {
        file << std::setw(4) << std::setfill('0') << i << ": " << object_code[i] << "\n";
    }

    file << "\n--- Listas de Pendencias ---\n";
    for (const auto& pair : symtab) {
        if (!pair.second.pending_list.empty()) {
            file << "Simbolo '" << pair.first << "': pendente nos indices [ ";
            for (int loc : pair.second.pending_list) {
                file << loc << " ";
            }
            file << "]\n";
        }
    }
}

// O processo de backpatching: resolve todas as referências futuras.
void Assembler::backpatch() {
    // Itera sobre a tabela de símbolos.
    for (auto& pair : symtab) {
        SymbolInfo& info = pair.second;
        // Para cada símbolo que foi definido...
        if (info.is_defined) {
            //...itera sobre sua lista de pendências.
            for (int loc : info.pending_list) {
                // Substitui o placeholder (0) no código objeto pelo endereço real do símbolo.
                object_code[loc] = info.address;
            }
        }
    }
}

// Gera o arquivo de saída final.o2.
void Assembler::generate_o2_file(const std::string& filename) {
    std::ofstream file(filename);
    if (!file.is_open()) return;

    // Escreve todo o código objeto em uma única linha, separado por espaços.
    for (size_t i = 0; i < object_code.size(); ++i) {
        file << object_code[i] << (i == object_code.size() - 1? "" : " ");
    }
}

// Método orquestrador da classe Assembler.
void Assembler::assemble(const std::string& input_filename, const std::string& o1_filename, const std::string& o2_filename) {
    initialize_optab();
    first_pass(input_filename);

    // Se foram encontrados erros, imprime-os e interrompe a compilação.
    if (!errors.empty()) {
        for (const auto& err : errors) {
            std::cerr << "Erro na linha " << err.first << " do arquivo.pre: " << err.second << std::endl;
        }
        return;
    }

    // Se não houver erros, gera os arquivos de saída.
    generate_o1_file(o1_filename);
    backpatch();
    generate_o2_file(o2_filename);
}


-------


#ifndef ASSEMBLER_HPP
#define ASSEMBLER_HPP

#include "Lexer.hpp"
#include <string>
#include <vector>
#include <unordered_map>
#include <list>

// Estrutura para informações de uma operação/instrução na OPTAB.
struct OpInfo {
    int opcode;
    int size;           // Tamanho em palavras de memória.
    int num_operands;
};

// Estrutura para informações de um símbolo na SYMTAB.
// Esta é a estrutura chave para o algoritmo de passagem única.
struct SymbolInfo {
    int address;
    bool is_defined = false;       // Flag que indica se o símbolo já foi definido.
    std::list<int> pending_list; // Lista de endereços no código objeto que precisam ser corrigidos (backpatched).
};

// A classe Assembler implementa a Passagem 1 do compilador.
// Ela traduz o código do arquivo.pre para código objeto.
class Assembler {
public:
    // Método principal que orquestra a montagem.
    void assemble(const std::string& input_filename, const std::string& o1_filename, const std::string& o2_filename);

private:
    // Métodos privados que implementam as fases da montagem.
    void initialize_optab();
    void first_pass(const std::string& input_filename);
    void generate_o1_file(const std::string& filename);
    void backpatch();
    void generate_o2_file(const std::string& filename);
    
    // Analisador léxico para tokenizar o código.
    Lexer lexer;
    // Tabela de Operações (OPTAB).
    std::unordered_map<std::string, OpInfo> optab;
    // Tabela de Símbolos (SYMTAB).
    std::unordered_map<std::string, SymbolInfo> symtab;
    // Vetor para armazenar o código objeto gerado.
    std::vector<int> object_code;
    // Vetor para armazenar erros encontrados durante a montagem.
    std::vector<std::pair<int, std::string>> errors;
};

#endif // ASSEMBLER_HPP

------
#include "Preprocessor.hpp"
#include <sstream>
#include <iostream>
#include <algorithm>
#include <cctype>

// Função auxiliar para dividir uma linha em tokens (palavras).
// Trata espaços múltiplos e remove vírgulas dos operandos.
std::vector<std::string> Preprocessor::split(const std::string& s) {
    std::vector<std::string> tokens;
    std::string token;
    std::istringstream tokenStream(s);
    while (tokenStream >> token) {
        if (token.back() == ',') {
            token.pop_back();
        }
        if (!token.empty()) {
            tokens.push_back(token);
        }
    }
    return tokens;
}

// Método privado para expandir uma macro, com suporte a chamadas aninhadas (recursão).
void Preprocessor::expand_macro(const std::string& name, const std::vector<std::string>& args, std::ofstream& output_file) {
    // Busca a macro na Tabela de Nomes de Macro (MNT).
    const MntEntry& macro_info = mnt.at(name);

    // Itera sobre o corpo da macro na Tabela de Definição de Macro (MDT).
    for (size_t i = macro_info.mdt_start_index; i < mdt.size(); ++i) {
        std::string macro_line = mdt[i];
        
        // Para a expansão ao encontrar o "ENDMACRO" da definição atual.
        if (mdt[i] == "ENDMACRO") break;

        // Substitui os marcadores de parâmetro (ex: #1, #2) pelos argumentos reais da chamada.
        for (size_t j = 0; j < args.size(); ++j) {
            std::string placeholder = "#" + std::to_string(j + 1);
            size_t pos = macro_line.find(placeholder);
            while (pos!= std::string::npos) {
                macro_line.replace(pos, placeholder.length(), args[j]);
                pos = macro_line.find(placeholder, pos + args[j].length());
            }
        }
        
        // Após a substituição, verifica se a linha resultante é uma chamada de macro aninhada.
        std::vector<std::string> expanded_tokens = split(macro_line);
        if (!expanded_tokens.empty() && mnt.count(expanded_tokens)) {
            // É uma chamada aninhada. Coleta os argumentos e chama a si mesma recursivamente.
            std::vector<std::string> nested_args;
            for (size_t k = 1; k < expanded_tokens.size(); ++k) {
                nested_args.push_back(expanded_tokens[k]);
            }
            expand_macro(expanded_tokens, nested_args, output_file);
        } else {
            // Se não for uma chamada aninhada, escreve a linha expandida no arquivo de saída.
            output_file << macro_line << std::endl;
        }
    }
}


// Método principal que executa a Passagem 0.
void Preprocessor::process(const std::string& input_filename, const std::string& output_filename) {
    std::ifstream input_file(input_filename);
    std::ofstream output_file(output_filename);

    if (!input_file.is_open() ||!output_file.is_open()) {
        throw std::runtime_error("Nao foi possivel abrir os arquivos de pre-processamento.");
    }

    std::string line;
    bool is_defining_macro = false;
    MntEntry current_macro;

    while (std::getline(input_file, line)) {
        std::string upper_line = line;
        std::transform(upper_line.begin(), upper_line.end(), upper_line.begin(), ::toupper);
        
        std::vector<std::string> tokens = split(upper_line);
        if (tokens.empty()) {
            if (!is_defining_macro) output_file << line << std::endl;
            continue;
        }

        // Detecta o início de uma definição de macro (ex: "NOME: MACRO...")
        if (tokens.size() >= 2 && tokens[2] == "MACRO") {
            is_defining_macro = true;
            
            // O primeiro token é o rótulo da macro (ex: "NOME:")
            std::string label_part = tokens;
            current_macro.name = label_part.substr(0, label_part.length() - 1); // Remove o ":"
            
            current_macro.params.clear();
            // Os parâmetros começam a partir do terceiro token.
            for (size_t i = 2; i < tokens.size(); ++i) {
                current_macro.params.push_back(tokens[i]);
            }
            current_macro.mdt_start_index = mdt.size();
            continue;
        }

        // Detecta o fim de uma definição de macro.
        if (tokens == "ENDMACRO") {
            is_defining_macro = false;
            mnt[current_macro.name] = current_macro;
            mdt.push_back("ENDMACRO");
            continue;
        }

        // Se estiver no estado de definição, armazena a linha na MDT.
        if (is_defining_macro) {
            std::string processed_line = line;
            // Substitui os nomes dos parâmetros por marcadores posicionais (ex: #1, #2). [2]
            for (size_t i = 0; i < current_macro.params.size(); ++i) {
                std::string placeholder = "#" + std::to_string(i + 1);
                const std::string& param = current_macro.params[i];
                size_t pos = processed_line.find(param);
                while(pos!= std::string::npos) {
                    bool is_standalone = (pos == 0 ||!isalnum(processed_line[pos-1])) &&
                                         (pos + param.length() == processed_line.length() ||!isalnum(processed_line[pos + param.length()]));
                    if (is_standalone) {
                        processed_line.replace(pos, param.length(), placeholder);
                        pos = processed_line.find(param, pos + placeholder.length());
                    } else {
                        pos = processed_line.find(param, pos + 1);
                    }
                }
            }
            mdt.push_back(processed_line);
        } else {
            // Se não estiver definindo, verifica se é uma chamada de macro.
            size_t macro_name_idx = 0;
            if (tokens.back() == ':') {
                macro_name_idx = 1;
            }

            if (macro_name_idx < tokens.size() && mnt.count(tokens[macro_name_idx])) {
                std::string macro_name = tokens[macro_name_idx];
                
                std::vector<std::string> args;
                for (size_t i = macro_name_idx + 1; i < tokens.size(); ++i) {
                     args.push_back(tokens[i]);
                }

                if (macro_name_idx > 0) {
                    output_file << tokens << " ";
                }
                
                expand_macro(macro_name, args, output_file);

            } else {
                // Se não for uma chamada de macro, é código normal. Copia para a saída.
                output_file << line << std::endl;
            }
        }
    }
}


------

#include "Preprocessor.hpp"
#include <sstream>
#include <iostream>
#include <algorithm>
#include <cctype>

// Função auxiliar para dividir uma linha em tokens (palavras).
// Trata espaços múltiplos e remove vírgulas dos operandos.
std::vector<std::string> Preprocessor::split(const std::string& s) {
    std::vector<std::string> tokens;
    std::string token;
    std::istringstream tokenStream(s);
    while (tokenStream >> token) {
        if (token.back() == ',') {
            token.pop_back();
        }
        if (!token.empty()) {
            tokens.push_back(token);
        }
    }
    return tokens;
}

// Método privado para expandir uma macro, com suporte a chamadas aninhadas (recursão).
void Preprocessor::expand_macro(const std::string& name, const std::vector<std::string>& args, std::ofstream& output_file) {
    // Busca a macro na Tabela de Nomes de Macro (MNT).
    const MntEntry& macro_info = mnt.at(name);

    // Itera sobre o corpo da macro na Tabela de Definição de Macro (MDT).
    for (size_t i = macro_info.mdt_start_index; i < mdt.size(); ++i) {
        std::string macro_line = mdt[i];
        
        // Para a expansão ao encontrar o "ENDMACRO" da definição atual.
        if (mdt[i] == "ENDMACRO") break;

        // Substitui os marcadores de parâmetro (ex: #1, #2) pelos argumentos reais da chamada.
        for (size_t j = 0; j < args.size(); ++j) {
            std::string placeholder = "#" + std::to_string(j + 1);
            size_t pos = macro_line.find(placeholder);
            while (pos!= std::string::npos) {
                macro_line.replace(pos, placeholder.length(), args[j]);
                pos = macro_line.find(placeholder, pos + args[j].length());
            }
        }
        
        // Após a substituição, verifica se a linha resultante é uma chamada de macro aninhada.
        std::vector<std::string> expanded_tokens = split(macro_line);
        if (!expanded_tokens.empty() && mnt.count(expanded_tokens)) {
            // É uma chamada aninhada. Coleta os argumentos e chama a si mesma recursivamente.
            std::vector<std::string> nested_args;
            for (size_t k = 1; k < expanded_tokens.size(); ++k) {
                nested_args.push_back(expanded_tokens[k]);
            }
            expand_macro(expanded_tokens, nested_args, output_file);
        } else {
            // Se não for uma chamada aninhada, escreve a linha expandida no arquivo de saída.
            output_file << macro_line << std::endl;
        }
    }
}


// Método principal que executa a Passagem 0.
void Preprocessor::process(const std::string& input_filename, const std::string& output_filename) {
    std::ifstream input_file(input_filename);
    std::ofstream output_file(output_filename);

    if (!input_file.is_open() ||!output_file.is_open()) {
        throw std::runtime_error("Nao foi possivel abrir os arquivos de pre-processamento.");
    }

    std::string line;
    bool is_defining_macro = false;
    MntEntry current_macro;

    while (std::getline(input_file, line)) {
        std::string upper_line = line;
        std::transform(upper_line.begin(), upper_line.end(), upper_line.begin(), ::toupper);
        
        std::vector<std::string> tokens = split(upper_line);
        if (tokens.empty()) {
            if (!is_defining_macro) output_file << line << std::endl;
            continue;
        }

        // Detecta o início de uma definição de macro (ex: "NOME: MACRO...")
        if (tokens.size() >= 2 && tokens[2] == "MACRO") {
            is_defining_macro = true;
            
            // O primeiro token é o rótulo da macro (ex: "NOME:")
            std::string label_part = tokens;
            current_macro.name = label_part.substr(0, label_part.length() - 1); // Remove o ":"
            
            current_macro.params.clear();
            // Os parâmetros começam a partir do terceiro token.
            for (size_t i = 2; i < tokens.size(); ++i) {
                current_macro.params.push_back(tokens[i]);
            }
            current_macro.mdt_start_index = mdt.size();
            continue;
        }

        // Detecta o fim de uma definição de macro.
        if (tokens == "ENDMACRO") {
            is_defining_macro = false;
            mnt[current_macro.name] = current_macro;
            mdt.push_back("ENDMACRO");
            continue;
        }

        // Se estiver no estado de definição, armazena a linha na MDT.
        if (is_defining_macro) {
            std::string processed_line = line;
            // Substitui os nomes dos parâmetros por marcadores posicionais (ex: #1, #2). [2]
            for (size_t i = 0; i < current_macro.params.size(); ++i) {
                std::string placeholder = "#" + std::to_string(i + 1);
                const std::string& param = current_macro.params[i];
                size_t pos = processed_line.find(param);
                while(pos!= std::string::npos) {
                    bool is_standalone = (pos == 0 ||!isalnum(processed_line[pos-1])) &&
                                         (pos + param.length() == processed_line.length() ||!isalnum(processed_line[pos + param.length()]));
                    if (is_standalone) {
                        processed_line.replace(pos, param.length(), placeholder);
                        pos = processed_line.find(param, pos + placeholder.length());
                    } else {
                        pos = processed_line.find(param, pos + 1);
                    }
                }
            }
            mdt.push_back(processed_line);
        } else {
            // Se não estiver definindo, verifica se é uma chamada de macro.
            size_t macro_name_idx = 0;
            if (tokens.back() == ':') {
                macro_name_idx = 1;
            }

            if (macro_name_idx < tokens.size() && mnt.count(tokens[macro_name_idx])) {
                std::string macro_name = tokens[macro_name_idx];
                
                std::vector<std::string> args;
                for (size_t i = macro_name_idx + 1; i < tokens.size(); ++i) {
                     args.push_back(tokens[i]);
                }

                if (macro_name_idx > 0) {
                    output_file << tokens << " ";
                }
                
                expand_macro(macro_name, args, output_file);

            } else {
                // Se não for uma chamada de macro, é código normal. Copia para a saída.
                output_file << line << std::endl;
            }
        }
    }
}


-------


#include "Lexer.hpp"
#include <sstream>
#include <algorithm>
#include <cctype>

// Normaliza uma linha de código para facilitar a análise.
std::string Lexer::normalize(const std::string& line) {
    std::string result = line;
    
    // 1. Remove comentários: encontra o primeiro ';' e descarta tudo o que vem depois.
    size_t comment_pos = result.find(';');
    if (comment_pos!= std::string::npos) {
        result = result.substr(0, comment_pos);
    }
    
    // 2. Converte para maiúsculas para tornar o compilador insensível a maiúsculas/minúsculas.
    std::transform(result.begin(), result.end(), result.begin(), ::toupper);
    
    return result;
}

// Verifica se um caractere é válido para um rótulo, seguindo as regras do projeto:
// - O primeiro caractere deve ser uma letra ou '_'.
// - Os caracteres subsequentes podem ser letras, números ou '_'.
bool Lexer::is_valid_label_char(char c, bool is_first_char) {
    if (is_first_char) {
        return std::isalpha(c) |

| c == '_';
    }
    return std::isalnum(c) |

| c == '_';
}

// O coração do Lexer: transforma uma linha de texto em uma lista de tokens.
std::vector<Token> Lexer::tokenize(const std::string& line, int line_number) {
    std::string normalized_line = normalize(line);
    
    // Usa std::stringstream para dividir a linha em "palavras" separadas por espaços.
    // É uma alternativa mais segura e moderna ao `strtok` da linguagem C. [1]
    std::stringstream ss(normalized_line);
    std::string lexeme;
    std::vector<Token> tokens;

    // Extrai cada palavra (lexeme) da linha.
    while (ss >> lexeme) {
        Token t;
        t.line_number = line_number;
        
        // Classifica o lexema em um tipo de token.
        if (lexeme.back() == ':') {
            t.type = TokenType::LABEL;
            t.value = lexeme.substr(0, lexeme.length() - 1);
            // Validação léxica: verifica se o nome do rótulo é válido.
            for (size_t i = 0; i < t.value.length(); ++i) {
                if (!is_valid_label_char(t.value[i], i == 0)) {
                    throw LexicalError("Rotulo '" + t.value + "' contem caracteres invalidos ou comeca com numero.", line_number);
                }
            }
        } else if (lexeme == "ADD" |

| lexeme == "SUB" |
| lexeme == "MULT" |
| lexeme == "DIV" |
| 
                   lexeme == "JMP" |

| lexeme == "JMPN" |
| lexeme == "JMPP" |
| lexeme == "JMPZ" ||
                   lexeme == "COPY" |

| lexeme == "LOAD" |
| lexeme == "STORE" |
| lexeme == "INPUT" ||
                   lexeme == "OUTPUT" |

| lexeme == "STOP") {
            t.type = TokenType::MNEMONIC;
            t.value = lexeme;
        } else if (lexeme == "SPACE" |

| lexeme == "CONST" |
| lexeme == "MACRO" |
| lexeme == "ENDMACRO") {
            t.type = TokenType::DIRECTIVE;
            t.value = lexeme;
        } else if (std::all_of(lexeme.begin(), lexeme.end(), ::isdigit)) {
            t.type = TokenType::NUMBER;
            t.value = lexeme;
        } else {
            // Se não for nenhum dos anteriores, assume que é um operando (uma referência a um rótulo).
            t.type = TokenType::OPERAND;
            t.value = lexeme;
            // Validação léxica do operando.
             for (size_t i = 0; i < t.value.length(); ++i) {
                if (!is_valid_label_char(t.value[i], i == 0)) {
                    // Permite expressões simples como N+1.
                    size_t plus_pos = t.value.find('+');
                    if (plus_pos!= std::string::npos && plus_pos > 0) {
                        std::string base = t.value.substr(0, plus_pos);
                        std::string offset_str = t.value.substr(plus_pos + 1);
                        bool base_valid = true;
                        for(size_t j=0; j<base.length(); ++j) if(!is_valid_label_char(base[j], j==0)) base_valid = false;
                        bool offset_valid = std::all_of(offset_str.begin(), offset_str.end(), ::isdigit);
                        if(base_valid && offset_valid) continue; // Se for uma expressão válida, pula a exceção.
                    }
                    throw LexicalError("Operando ou rotulo '" + t.value + "' contem caracteres invalidos ou comeca com numero.", line_number);
                }
            }
        }
        tokens.push_back(t);
    }
    return tokens;
}



-----

#ifndef LEXER_HPP
#define LEXER_HPP

#include "Token.hpp"
#include <string>
#include <vector>
#include <stdexcept>

// Classe de exceção personalizada para erros léxicos.
// Herda de std::runtime_error para se integrar ao sistema de exceções padrão do C++.
// Armazena a mensagem de erro e o número da linha para relatórios de erro precisos.
class LexicalError : public std::runtime_error {
public:
    LexicalError(const std::string& message, int line) 
        : std::runtime_error(message), line_number(line) {}
    int getLine() const { return line_number; }
private:
    int line_number;
};

// A classe Lexer (Analisador Léxico) é responsável por converter uma string de código-fonte
// em uma lista de tokens.
class Lexer {
public:
    // O método principal que realiza a tokenização de uma única linha de código.
    std::vector<Token> tokenize(const std::string& line, int line_number);

private:
    // Função auxiliar para normalizar uma linha: remove comentários e converte para maiúsculas.
    std::string normalize(const std::string& line);
    // Função auxiliar para validar se um caractere é válido para um rótulo/identificador.
    bool is_valid_label_char(char c, bool is_first_char);
};

#endif // LEXER_HPP


-------

#ifndef TOKEN_HPP
#define TOKEN_HPP

#include <string>
#include <vector>

// Enumeração para classificar os diferentes tipos de tokens que nosso compilador pode encontrar.
// Um token é a menor unidade de significado em um programa, como uma palavra-chave, um número ou um operador.
enum class TokenType {
    LABEL,          // Ex: LOOP:
    MNEMONIC,       // Ex: ADD, SUB, JMP
    DIRECTIVE,      // Ex: SPACE, CONST, MACRO
    OPERAND,        // Ex: N1, VAR, LOOP
    NUMBER,         // Ex: 10, -5
    COMMA,          // Ex: , (usado em instruções como COPY)
    UNKNOWN         // Token não reconhecido
};

// Estrutura para representar um único token.
// Contém o tipo do token, seu valor como string e a linha onde foi encontrado.
struct Token {
    TokenType type;
    std::string value;
    int line_number;
};

#endif // TOKEN_HPP